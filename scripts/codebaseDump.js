// FILE: scripts/codebase_dumper_combined.js
import { program } from "commander";
import { promises as fs } from "fs";
import path from "path";
import process from "process";

async function generateFileDump(
  projectRoot,
  outputFile,
  targetFolder,
  includeNatives
) {
  const defaultExcludeDirs = new Set([
    ".git",
    "__pycache__",
    "node_modules",
    ".expo",
    ".yarn",
    "coverage",
    "build",
    ".gradle",
    ".idea",
    ".cxx",
    "xcuserdata",
    "DerivedData",
    "Pods",
    "fastlane",
    "bundle",
    "ios", // Included by default
    "android", // Included by default
    "codebase",
    "assets",
    ".github",
  ]);

  const defaultExcludeFiles = new Set([
    "package-lock.json",
    "pnpm-lock.yaml",
    "bun.lockb",
    ".DS_Store",
    "local.properties",
    ".xcode.env.local",
    "npm-debug.log",
    "yarn-error.log",
    ".metro-health-check",
  ]);

  const defaultExcludeExtensions = new Set([
    // Common Binary/Unreadable Files
    ".apk",
    ".aar",
    ".jar", // Android binaries
    ".keystore",
    ".jks", // Java keystores (binary/sensitive)
    ".hprof", // Heap dumps
    ".iml", // IntelliJ module files
    ".pbxuser",
    ".mode1v3",
    ".mode2v3",
    ".perspectivev3", // Xcode user settings
    ".xccheckout",
    ".moved-aside",
    ".hmap",
    ".ipa",
    ".xcuserstate", // Xcode build/cache
    ".jsbundle", // React Native JS bundle (often minified/packed)
    ".wasm", // WebAssembly binary
    ".dat", // Generic data files (often binary)
    ".bin", // Generic binary files
    ".db",
    ".sqlite", // Database files
    ".obj",
    ".pdb",
    ".tlog",
    ".lib",
    ".exp",
    ".dll",
    ".so",
    ".dylib", // Compiled binaries/libraries
    ".class",
    ".dex", // Java/Android compiled code
    ".gradle-build", // More Gradle build artifacts
    ".log", // Generic log files (can be large, rarely useful for code dump)
    ".lock", // Generic lock files (often structured, but can be large/binary)

    // Image formats (corrected .webp)
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".bmp",
    ".tiff",
    ".ico",
    ".webp",
    ".heic",

    // Audio/Video formats
    ".mp3",
    ".wav",
    ".ogg",
    ".flac",
    ".aac",
    ".mp4",
    ".mov",
    ".avi",
    ".wmv",
    ".mkv",
    ".webm",

    // Font files
    ".ttf",
    ".otf",
    ".woff",
    ".woff2",

    // Archive/Compressed files
    ".zip",
    ".tar",
    ".gz",
    ".rar",
    ".7z",
    ".bz2",
    ".xz",

    // Other common non-code files
    ".pdf",
    ".doc",
    ".docx",
    ".xls",
    ".xlsx",
    ".ppt",
    ".pptx",
    ".psd",
    ".ai",
    ".indd",
    ".exe",
    ".dmg",
    ".app",
  ]);

  const excludeDirs = new Set(defaultExcludeDirs);
  if (includeNatives) {
    excludeDirs.delete("ios");
    excludeDirs.delete("android");
  }

  const excludeFiles = new Set(defaultExcludeFiles);
  const excludeExtensions = new Set(defaultExcludeExtensions);

  let outputContent = `// AUTOGENERATED CODEBASE DUMP\n`;
  outputContent += `// Project Root: ${projectRoot}\n`;
  if (targetFolder) {
    outputContent += `// Target Folder: ${targetFolder}\n\n`;
  } else {
    outputContent += `// Target Folder: All\n\n`;
  }

  async function walk(currentDir) {
    const entries = await fs.readdir(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const entryPath = path.join(currentDir, entry.name);
      const relativePath = path.relative(projectRoot, entryPath);
      const parts = relativePath.split(path.sep);

      if (entry.isDirectory()) {
        if (!parts.some((part) => excludeDirs.has(part))) {
          if (!targetFolder || relativePath.startsWith(targetFolder)) {
            await walk(entryPath);
          }
        }
      } else if (entry.isFile()) {
        const fileExtension = path.extname(entry.name).toLowerCase(); // Convert to lowercase for consistent matching
        if (
          !parts.some((part) => excludeDirs.has(part)) &&
          !excludeFiles.has(entry.name) &&
          !excludeExtensions.has(fileExtension)
        ) {
          try {
            const content = await fs.readFile(entryPath, "utf-8");
            outputContent += `\n// FILE: ${relativePath}\n`;
            outputContent += content + "\n";
          } catch (error) {
            // The 'error' variable is used here to provide specific error messages.
            // This avoids the linter warning about unused 'error' variables.
            if (
              error.code === "ERR_INVALID_ARG_VALUE" ||
              error.code === "ERR_BUFFER_TOO_LARGE"
            ) {
              outputContent += `\n// FILE: ${relativePath} (Skipped due to unreadable content or size limit)\n`;
            } else {
              // For other errors, still log them
              outputContent += `\n// ERROR READING ${relativePath}: ${error.message}\n`;
            }
          }
        }
      }
    }
  }

  const resolvedProjectRoot = path.resolve(projectRoot);

  if (targetFolder) {
    const targetPath = path.join(resolvedProjectRoot, targetFolder);
    try {
      const stats = await fs.stat(targetPath);
      if (!stats.isDirectory()) {
        console.error(`Error: Target folder '${targetFolder}' not found.`);
        return;
      }
      await walk(targetPath);
    } catch {
      // Changed from catch (error) to catch {} as the error object itself was not used here
      console.error(`Error: Target folder '${targetFolder}' not found.`);
      return;
    }
  } else {
    await walk(resolvedProjectRoot);
  }

  try {
    await fs.writeFile(outputFile, outputContent, "utf-8");
    console.log(`File dump created: ${path.resolve(outputFile)}`);
  } catch (error) {
    console.error(`Error writing to output file: ${error}`);
  }
}

async function main() {
  program
    .arguments(
      "[targetFolder]",
      "Optional target folder to dump (e.g., 'helpers', 'components')."
    )
    .option(
      "--natives",
      "Include the native android/ and ios/ folders in the dump."
    )
    .parse(process.argv);

  const targetFolder = program.args[0];
  const includeNatives = program.opts().natives || false;
  const projectRoot = process.cwd();
  const desktopDir = path.join(
    process.env.HOME || process.env.USERPROFILE || process.env.HOMEPATH,
    "Desktop"
  );
  const parentFolderName = path.basename(projectRoot);
  const timestamp = new Date()
    .toLocaleTimeString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    })
    .replace(/:/g, "");
  const outputFilename = `${parentFolderName}_${timestamp}.txt`;
  const outputFile = path.join(desktopDir, outputFilename);

  await generateFileDump(projectRoot, outputFile, targetFolder, includeNatives);
}

main();
